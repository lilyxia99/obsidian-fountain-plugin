/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FountainPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// fountain-cm6.ts
var import_view = require("@codemirror/view");
var regexPatterns = {
  // Scene Headings: INT, EXT, EST, I/E, INT/EXT, etc., or starting with a period (forced)
  sceneHeading: /^(?:INT\.|EXT\.|EST\.|INT\/EXT\.|I\/E\.|I\/X\.).*|^\.[^.].*$/i,
  // Transitions: ends with TO:, or explicitly matching CUT TO:, FADE OUT., etc., or starting with >
  transition: /^(?:[A-Z\s]+TO:|FADE TO BLACK\.|FADE OUT\.|CUT TO BLACK\.|>.*[^<])$/i,
  // Centered text starts with > and ends with <
  centered: /^>\s*.*\s*<$/,
  // Character names are uppercase, can have numbers/spaces, and optionally a parenthetical (V.O.) at the end. Can't be empty.
  character: /^[\s]*[A-Z0-9\s]+(?: \([^)]+\))?\s*(?:\^)?$/,
  // Parenthetical must be wrapped in ()
  parenthetical: /^\s*\([^)]+\)\s*$/
};
var DualDialogueWidget = class extends import_view.WidgetType {
  constructor(leftLines, rightLines) {
    super();
    this.leftLines = leftLines;
    this.rightLines = rightLines;
  }
  eq(other) {
    if (this.leftLines.length !== other.leftLines.length || this.rightLines.length !== other.rightLines.length)
      return false;
    for (let i = 0; i < this.leftLines.length; i++) {
      if (this.leftLines[i].text !== other.leftLines[i].text)
        return false;
    }
    for (let i = 0; i < this.rightLines.length; i++) {
      if (this.rightLines[i].text !== other.rightLines[i].text)
        return false;
    }
    return true;
  }
  toDOM() {
    const container = document.createElement("div");
    container.className = "fountain-dual-dialogue-container";
    container.style.display = "flex";
    container.style.justifyContent = "space-between";
    container.style.width = "100%";
    container.style.marginTop = "1em";
    container.style.marginBottom = "1em";
    const leftCol = document.createElement("div");
    leftCol.className = "fountain-dual-col-left";
    leftCol.style.flex = "1";
    leftCol.style.marginRight = "20px";
    this.leftLines.forEach((line) => {
      const el = document.createElement("div");
      el.className = `fountain-${line.type} fountain-dual-left`;
      el.innerText = line.text;
      leftCol.appendChild(el);
    });
    const rightCol = document.createElement("div");
    rightCol.className = "fountain-dual-col-right";
    rightCol.style.flex = "1";
    rightCol.style.marginLeft = "20px";
    this.rightLines.forEach((line) => {
      const el = document.createElement("div");
      el.className = `fountain-${line.type} fountain-dual-right`;
      if (line.type === "character") {
        el.className += " fountain-dual-caret";
      }
      el.innerText = line.text;
      rightCol.appendChild(el);
    });
    container.appendChild(leftCol);
    container.appendChild(rightCol);
    return container;
  }
  ignoreEvent() {
    return false;
  }
};
var buildDecorations = (view) => {
  const builder = [];
  const doc = view.state.doc;
  let i = 1;
  let lastLineWasCharacter = false;
  let lastLineWasParenthetical = false;
  let lastLineWasDialogue = false;
  let lastLineWasEmpty = true;
  const decos = [];
  while (i <= doc.lines) {
    const line = doc.line(i);
    const text = line.text;
    const trimmed = text.trim();
    let customType = "";
    if (trimmed === "") {
      customType = "empty";
      lastLineWasEmpty = true;
      lastLineWasCharacter = false;
      lastLineWasParenthetical = false;
      lastLineWasDialogue = false;
    } else {
      if (regexPatterns.sceneHeading.test(trimmed)) {
        customType = "scene-heading";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = false;
      } else if (regexPatterns.centered.test(trimmed)) {
        customType = "centered";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = false;
      } else if (regexPatterns.transition.test(trimmed)) {
        customType = "transition";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = false;
      } else if (lastLineWasEmpty && regexPatterns.character.test(text) && !regexPatterns.sceneHeading.test(trimmed) && !regexPatterns.transition.test(trimmed)) {
        customType = "character";
        lastLineWasCharacter = true;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = false;
      } else if ((lastLineWasCharacter || lastLineWasParenthetical || lastLineWasDialogue) && regexPatterns.parenthetical.test(trimmed)) {
        customType = "parenthetical";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = true;
        lastLineWasDialogue = false;
      } else if (lastLineWasCharacter || lastLineWasParenthetical || lastLineWasDialogue) {
        customType = "dialogue";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = true;
      } else {
        customType = "action";
        lastLineWasCharacter = false;
        lastLineWasParenthetical = false;
        lastLineWasDialogue = false;
      }
      lastLineWasEmpty = false;
    }
    decos.push({
      lineNum: i,
      from: line.from,
      to: line.to,
      type: customType,
      text: trimmed
    });
    i++;
  }
  const blocksToReplace = [];
  for (let j = 0; j < decos.length; j++) {
    const deco = decos[j];
    if (deco.type === "character" && deco.text.endsWith("^") && !deco.isDualProcessed) {
      const rightGroup = [deco];
      let k = j + 1;
      while (k < decos.length) {
        if (decos[k].type === "dialogue" || decos[k].type === "parenthetical") {
          rightGroup.push(decos[k]);
          k++;
        } else if (decos[k].type === "empty" && k + 1 < decos.length && (decos[k + 1].type === "dialogue" || decos[k + 1].type === "parenthetical")) {
          rightGroup.push(decos[k]);
          k++;
        } else {
          break;
        }
      }
      let findLeft = j - 1;
      const emptyMiddleGroup = [];
      while (findLeft >= 0 && decos[findLeft].type === "empty") {
        emptyMiddleGroup.unshift(decos[findLeft]);
        findLeft--;
      }
      const leftGroup = [];
      while (findLeft >= 0) {
        if (decos[findLeft].type === "dialogue" || decos[findLeft].type === "parenthetical") {
          leftGroup.unshift(decos[findLeft]);
          findLeft--;
        } else if (decos[findLeft].type === "character") {
          leftGroup.unshift(decos[findLeft]);
          break;
        } else if (decos[findLeft].type === "empty" && findLeft - 1 >= 0 && (decos[findLeft - 1].type === "dialogue" || decos[findLeft - 1].type === "parenthetical" || decos[findLeft - 1].type === "character")) {
          leftGroup.unshift(decos[findLeft]);
          findLeft--;
        } else {
          break;
        }
      }
      if (leftGroup.length > 0 && leftGroup[0].type === "character") {
        leftGroup.forEach((item) => item.isDualProcessed = true);
        emptyMiddleGroup.forEach((item) => item.isDualProcessed = true);
        rightGroup.forEach((item) => item.isDualProcessed = true);
        const blockFrom = leftGroup[0].from;
        const blockTo = rightGroup[rightGroup.length - 1].to;
        blocksToReplace.push({
          from: blockFrom,
          to: blockTo,
          leftBlock: leftGroup,
          rightBlock: rightGroup
        });
      }
    }
  }
  for (const b of blocksToReplace) {
    builder.push(import_view.Decoration.replace({
      widget: new DualDialogueWidget(
        b.leftBlock.filter((l) => l.type !== "empty"),
        b.rightBlock.filter((l) => l.type !== "empty")
      ),
      block: true
    }).range(b.from, b.to));
  }
  for (const deco of decos) {
    if (deco.isDualProcessed)
      continue;
    if (deco.type === "empty")
      continue;
    const cls = `fountain-${deco.type}`;
    builder.push(import_view.Decoration.line({ class: cls }).range(deco.from));
  }
  builder.sort((a, b) => a.from - b.from);
  return import_view.Decoration.set(builder);
};
var fountainViewPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = buildDecorations(update.view);
      }
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var fountainLivePreview = [
  fountainViewPlugin
];

// settings.ts
var import_obsidian = require("obsidian");
var defaultCss = `/* Scene Headings */
    .markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - scene - heading {
    text - transform: uppercase!important;
    font - weight: bold!important;
}

/* Character */
/* ~2.2 inches from left text margin */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - character {
    text - align: left!important;
    margin - left: 22ch!important;
    text - transform: uppercase!important;
}

/* Dialogue */
/* ~1.0 inches from left text margin, ~3.5 inches wide */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dialogue {
    margin - left: 10ch!important;
    max - width: 40ch!important;
}

/* Parenthetical */
/* ~1.6 inches from left text margin, ~2.0 inches wide */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - parenthetical {
    text - align: left!important;
    margin - left: 16ch!important;
    max - width: 25ch!important;
}

/* Transitions */
/* Flush right or ~4.0 inches from left */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - transition {
    text - align: right!important;
    text - transform: uppercase!important;
}

/* Centered */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - centered {
    text - align: center!important;
}

/* Dual Dialogue Left */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - left.fountain - character {
    margin - left: 5ch!important;
}
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - left.fountain - dialogue {
    margin - left: 0ch!important;
    max - width: 30ch!important;
}
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - left.fountain - parenthetical {
    margin - left: 2ch!important;
}

/* Dual Dialogue Right (Shifted to the right side of the screen) */
/* In Live Preview, true flexbox side-by-side isn't possible because lines cannot be wrapped */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - right.fountain - character {
    margin - left: 45ch!important;
}
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - right.fountain - dialogue {
    margin - left: 40ch!important;
    max - width: 30ch!important;
}
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - right.fountain - parenthetical {
    margin - left: 42ch!important;
}

/* Hide the caret from dual dialogue character */
.markdown - source - view.mod - cm6.cm - content > .cm - line.fountain - dual - caret {
    /* Optional */
} `;
var DEFAULT_SETTINGS = {
  customCss: defaultCss
};
var FountainSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Fountain Live Preview Settings" });
    containerEl.createEl("div", { text: "You can directly edit the CSS used for Fountain element rendering in the Live Preview here. This provides maximum flexibility." });
    new import_obsidian.Setting(containerEl).setName("Reset CSS to Defaults").setDesc("If you messed up your CSS or want to load newly added CSS features (like Dual Dialogue), click this button.").addButton((button) => {
      button.setButtonText("Reset Defaults").setWarning().onClick(async () => {
        this.plugin.settings.customCss = defaultCss;
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
};

// main.ts
var FountainPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("Loading Fountain Live Preview plugin");
    await this.loadSettings();
    this.registerExtensions(["fountain"], "markdown");
    this.registerEditorExtension(fountainLivePreview);
    this.addSettingTab(new FountainSettingTab(this.app, this));
    this.styleTag = document.createElement("style");
    this.styleTag.id = "fountain-custom-css";
    document.head.appendChild(this.styleTag);
    this.applyCssSettings();
  }
  onunload() {
    console.log("Unloading Fountain Live Preview plugin");
    if (this.styleTag) {
      this.styleTag.remove();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.applyCssSettings();
  }
  applyCssSettings() {
    if (this.styleTag) {
      this.styleTag.innerText = this.settings.customCss;
    }
  }
};
